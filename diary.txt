April 1, 2018
Got back to work.  Took more than an hour, even with code in Clojure, to 
figure out where I left off and where to go next.  I feel like I've got
myself reoriented and can pick up.  Next: exponents! 

April 11, 2018
Don't care about having Pequod conform to functional principles at the moment. 
I need to build my understanding of the model first.  I can always refactor
later, and I definitely will.  But I need to wrap my head around the code.

April 14, 2018
Took my birthday off, and Friday off because it's Friday.  But back to work on
Saturday: Conversion is continuing well.  Nearly done with the big setup function
conversion.  Got a couple more things to wrap up.  Hoping to have most of the 
main undergirding done soon.  Then got to figure out ways to interact with it
in a clean interface.  Maybe I'll steal an idea from ants.clj?

April 21, 2018
It's coming easier now.  Continuing with building helper functions and moving along with lorenz-and-gini updates.  I feel like I'm making steady progress.

May 13, 2018
With the UDC Conference done, I'm back to work on this.  Got a paper notebook to help
with grokking.  It might be a blessing that I've been away from activism for a while.
It helps me to see things with new eyes.  I can understand that we need to be involved
in the day-to-day, especially with such immediate suffering, but no thought it brought
to vision or how to instantiate it.  That can help reduce the suffering, in spades.  Enough
writing.  Back to work.

May 20, 2018
Good day.  Got through the lorenz-and-gini function.  I even made a commit.  I'm moving 
on to the go function, and particularly to the proposal function, and further still to
solution1.nls.  Hoo boy.  This looks complicated.  I might want to ask for help, but not
before I give it a try first.

May 28, 2018
Spoke with Michael over the phone.  Good call.  Here are the notes from the call.

Lagrangian multiplier method (optimizing a function, finding a max or min; NOT a numerical method)
ef -> effort component, treated differently
Effort constraint: S
Past debate: Use numeric methods?
Future direction: Use analytical methods?
Why does it blow up when there are an odd number of terms?
Search term: Constrained optimization problem
Clojure core.logic

June 4, 2018
Notes from call with Robin and Michael:
1.  It doesn't work.
2.  It takes a long time.
pledge not fail at retirement
July 1st: Return.  Be ready! 
S: How much do you dislike effort
k: Diminishing return to more effort
value of their product (price of product * quantity) - (price of inputs * inputs) - Se^k [effort terms]

June 10, 2018
Excellent progress in converting all the under-the-hood functions into Clojure.  I feel like I understand
all the pieces and how they fit together.  I have the pieces; now it's a matter of getting them to fit
together.  I'll email Michael (cc: Robin) tomorrow and work on that next!

June 23, 2018
Getting closer.  Got expresso loaded and working with equations.  So far so good.  Am confused with
the notation of the Solve[] command.  Will write to Michael to clarify. 

June 28, 2018
After emailing Michael with a reminder, I finally got the answer needed.  The notation I was confused
by was a mistake.  It's now clear.  Back to work.

July 9, 2018
No response from Michael in days; ditto Robin.  Admittedly, it's the summer.  But at the same time
the notes from Michael regarding research into computing through the equations has not been great.
No matter; am trying another approach.  I found a library called symja that looks like it could be 
useful.  Am seeing if it can (1) compute the equations as Mathematica did, and (2) can it be ported
into Clojure (it's written in Java, so there's a prayer's chance it can).  Continuing...

July 15, 2018
On Friday morning I got an idea: Use Wolfram as an API, have it compute the equations, then deliver the results
back as a web call to -- whatever, the Clojure code, the Wolfram code, the Netlogo code, what have you.
I spoke with Robin over the phone about the idea; he was OK with giving it a try and discussing next week.
Yesterday, I spent the evening working out the details after a whole lot of trial and error.  After 
maybe 40 builds, I finally got the output I wanted.  And today, after watching the FIFA men's World Cup
final, I got it to a working API.  Here it is: 

http://www.wolframcloud.com/objects/0f665c3f-4fe9-4ddb-8713-6f9947270a12?n=1

Change the n=1 value to some other number and it'll recompute.  I should test this out to confirm that
this scales.  Next thoughts: Memoize and write a function to convert this to Clojure.

July 24, 2018
Better version:

https://www.wolframcloud.com/objects/6418ed29-be1b-4552-b600-ca5f13689f43?n=3

Much more compact, easier to parse.

October 5, 2018

Okay.  I'm giving myself a deadline of getting this app done in working form in 3 months.  I'm tired of
letting this linger like an albatross over my head.  And to make _sure_ this gets done, I'm locking
myself into a presentation to give in January -- I _have_ to get this done, so that I have the presentation
done. 
